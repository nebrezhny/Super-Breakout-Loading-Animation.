<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Loading...</title>
    <link rel="icon" type="image/png" href="/7C.png">
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f3f3eb;
        }
        canvas {
            background: #f3f3eb;
        }
    </style>
</head>
<body>
    <canvas id="breakout" width="823" height="230"></canvas>
    <script>
        const canvas = document.getElementById('breakout');
        const ctx = canvas.getContext('2d');

        // Brick settings
    const brickWidth = Math.round((12 * 1.25 * 1.25) / 1.25); // scale down
    const brickHeight = Math.round(((3 * 1.25) / 1.25) * 1.12); // increase height by 1.12x
    const brickPadding = Math.round(3 / 1.25); // scale down
    const brickOffsetTop = Math.round(16 / 1.25);
    const brickOffsetLeft = Math.round(8 / 1.25);

        // Ball settings
        let ballRadius = 5;
        let x = canvas.width / 2;
        let y = canvas.height - 30;
        let speed = 4;
        let angle = Math.PI * (0.25 + 0.5 * Math.random());
        let dx = speed * Math.cos(angle);
        let dy = -speed * Math.sin(angle);

        // Paddle settings
        const paddleHeight = 8;
        const paddleWidth = 40;
    let paddleX = (canvas.width - paddleWidth) / 2;
    let paddleSpeed = 5.6;
    const paddleSpeedNormal = 5.6;
    const paddleSpeedBoost = 13; // Boosted speed
    let paddleBoostActive = false;
        let paddleMode = 'random'; // 'random' or 'track'
        let randomMoveTimer = 0;
        let randomMoveDuration = 0;
        let randomMoveDirection = 1;
        let randomMoveDistance = 0;
        let oscillatePhase = 0;
        let oscillateRange = paddleWidth / 2;
        let oscillateOffset = 0;
        let overshootDir = 1;
        let overshootUturn = false;
        let lastLandingX = null;

        // Anti-stuck logic
        let nonBrickHitCount = 0;
        let consecutiveNoTargetBounces = 0;
        let lastHitWasBrick = false;

        // Bricks array
        // Use ASCII art to define the brick pattern
    const BRICK_ART = [
    `__              ______        ______      ________        ______      __      __      ________`,
    `__            __      __    __      __    __      __        __        ____    __    __        `,
    `__            __      __    __      __    __      __        __        ____    __    __        `,
    `__            __      __    __      __    __      __        __        __  __  __    __        `,
    `__            __      __    __      __    __      __        __        __  __  __    __        `,
    `__            __      __    __________    __      __        __        __    ____    __  ______`,
    `__            __      __    __      __    __      __        __        __      __    __      __`,
    `__            __      __    __      __    __      __        __        __      __    __      __`,
    `__            __      __    __      __    __      __        __        __      __    __      __`,
    `__            __      __    __      __    __      __        __        __      __    __      __`,
    `__________      ______      __      __    ________        ______      __      __      ________`,
    `__________      ______      __      __    ________        ______      __      __      ________`,
];

        // Parse ASCII art in steps of 2 chars per column
        const brickRowCountArt = BRICK_ART.length;
        const brickColumnCountArt = Math.floor(BRICK_ART[0].length / 2);

        let bricks = [];
        for (let c = 0; c < brickColumnCountArt; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCountArt; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 0 };
            }
        }

        for (let r = 0; r < brickRowCountArt; r++) {
            for (let c = 0; c < brickColumnCountArt; c++) {
                const pair = BRICK_ART[r].substr(c * 2, 2);
                if (pair === '__') {
                    bricks[c][r].status = 1;
                }
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#0d0d19";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0d0d19";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    if (bricks[c][r].status === 1) {
                        let totalWidth = bricks.length * (brickWidth + brickPadding) - brickPadding;
                        let totalHeight = bricks[0].length * (brickHeight + brickPadding) - brickPadding;
                        // Center the art in the canvas
                        let offsetX = (canvas.width - totalWidth) / 2;
                        let offsetY = brickOffsetTop;
                        let brickX = (c * (brickWidth + brickPadding)) + offsetX;
                        let brickY = (r * (brickHeight + brickPadding)) + offsetY;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#0d0d19";
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function collisionDetection() {
            let hitBrick = false;
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    let b = bricks[c][r];
                    if (b.status === 1) {
                        if (
                            x + ballRadius > b.x &&
                            x - ballRadius < b.x + brickWidth &&
                            y + ballRadius > b.y &&
                            y - ballRadius < b.y + brickHeight
                        ) {
                            let hitPos = (x - (b.x + brickWidth / 2)) / (brickWidth / 2);
                            angle = Math.atan2(dy, dx) - hitPos * 0.3;
                            dx = speed * Math.cos(angle);
                            dy = -Math.abs(speed * Math.sin(angle));
                            b.status = 0;
                            hitBrick = true;
                        }
                    }
                }
            }
            if (hitBrick) {
                nonBrickHitCount = 0;
                consecutiveNoTargetBounces = 0;
                lastHitWasBrick = true;
            } else {
                lastHitWasBrick = false;
            }
        }

        function predictBallLandingX() {
            let tx = x, ty = y, tdx = dx, tdy = dy;
            while (tdy > 0 && ty < canvas.height - paddleHeight - ballRadius) {
                tx += tdx;
                ty += tdy;
                if (tx + ballRadius > canvas.width || tx - ballRadius < 0) tdx = -tdx;
                if (ty - ballRadius < 0) tdy = -tdy;
            }
            return Math.max(0, Math.min(canvas.width - paddleWidth, tx - paddleWidth / 2));
        }

        function updatePaddle() {
            // --- Paddle Speed Boost Logic ---
            // Find the lowest brick Y
            let lowestBrickY = 0;
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    if (bricks[c][r].status === 1) {
                        let y = bricks[c][r].y + brickHeight;
                        if (y > lowestBrickY) lowestBrickY = y;
                    }
                }
            }
            // If ball is below lowest brick and moving down
            if (y > lowestBrickY && dy > 0) {
                // Predict landing X
                let landingX = predictBallLandingX();
                let paddleCenter = paddleX + paddleWidth / 2;
                let dist = Math.abs(landingX + paddleWidth / 2 - paddleCenter);
                let framesToLand = (canvas.height - paddleHeight - y) / Math.abs(dy);
                let framesToReach = dist / paddleSpeedNormal;
                // If paddle can't reach in time from halfway down canvas, boost speed
                if (framesToReach > framesToLand && y > canvas.height / 2) {
                    paddleSpeed = paddleSpeedBoost;
                    paddleBoostActive = true;
                } else {
                    paddleSpeed = paddleSpeedNormal;
                    paddleBoostActive = false;
                }
            } else if (!paddleBoostActive) {
                paddleSpeed = paddleSpeedNormal;
            }
            if (dy < 0) {
                // Random walk when ball is going up
                if (paddleMode !== 'random') {
                    paddleMode = 'random';
                    randomMoveTimer = 0;
                    randomMoveDuration = 0;
                }
                if (randomMoveTimer <= 0) {
                    randomMoveDirection = Math.random() < 0.5 ? -1 : 1;
                    randomMoveDistance = 20 + Math.random() * 40;
                    randomMoveDuration = Math.abs(randomMoveDistance / paddleSpeed);
                    randomMoveTimer = randomMoveDuration;
                }
                let target = paddleX + randomMoveDirection * paddleSpeed;
                if (target < 0) target = 0;
                if (target > canvas.width - paddleWidth) target = canvas.width - paddleWidth;
                if (Math.abs(paddleX - target) > paddleSpeed) {
                    paddleX += paddleSpeed * Math.sign(target - paddleX);
                } else {
                    paddleX = target;
                    randomMoveTimer--;
                }
            } else {
                // Ball is coming down, oscillate around predicted landing
                if (paddleMode !== 'track') {
                    paddleMode = 'track';
                    oscillatePhase = 0;
                    oscillateOffset = 0;
                    overshootDir = Math.random() < 0.5 ? -1 : 1;
                    overshootUturn = false;
                    lastLandingX = null;
                }
                let landingX = predictBallLandingX();
                // Guarantee the paddle will always cover the ball
                let minX = Math.max(0, landingX - paddleWidth / 2);
                let maxX = Math.min(canvas.width - paddleWidth, landingX + paddleWidth / 2);
                // Oscillate smoothly within [-oscillateRange, +oscillateRange] from landingX, but clamp so paddle always covers ball
                // Make oscillation speed exactly match paddleSpeed (1:1 ratio)
                oscillatePhase += paddleSpeed / 20; // 20 is a tuning constant for natural look
                let osc = Math.sin(oscillatePhase) * (paddleWidth / 2);
                let target = landingX + osc;
                if (target < minX) target = minX;
                if (target > maxX) target = maxX;
                if (Math.abs(paddleX - target) > paddleSpeed) {
                    paddleX += paddleSpeed * Math.sign(target - paddleX);
                } else {
                    paddleX = target;
                }
            }
        }

        function deflectBall() {
            let currentAngle = Math.atan2(dy, dx);
            let deflect = (Math.random() - 0.5) * (Math.PI / 6);
            let newAngle = currentAngle + deflect;
            let newSpeed = Math.sqrt(dx * dx + dy * dy);
            dx = newSpeed * Math.cos(newAngle);
            dy = newSpeed * Math.sin(newAngle);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawBall();
            drawPaddle();
            collisionDetection();

            let deflectNext = false;

            // Ball-wall collision
            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
                dx = -dx;
                nonBrickHitCount++;
                consecutiveNoTargetBounces++;
                if (nonBrickHitCount >= 5 || consecutiveNoTargetBounces >= 4) deflectNext = true;
            }
            if (y + dy < ballRadius) {
                dy = -dy;
                nonBrickHitCount++;
                consecutiveNoTargetBounces++;
                if (nonBrickHitCount >= 5 || consecutiveNoTargetBounces >= 4) deflectNext = true;
            }

            // Ball-paddle collision
            if (y + dy > canvas.height - ballRadius - paddleHeight &&
                x > paddleX && x < paddleX + paddleWidth) {
                // Reset paddle speed after hit
                paddleSpeed = paddleSpeedNormal;
                paddleBoostActive = false;
                let hit = (x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                let bounceAngle = hit * (Math.PI / 3);
                speed = Math.min(5, speed + 0.05);
                dx = speed * Math.sin(bounceAngle);
                dy = -Math.abs(speed * Math.cos(bounceAngle));
                // Add a small random angle to the bounce
                let angleJitter = (Math.random() - 0.5) * (Math.PI / 24); // Â±7.5deg
                let newAngle = Math.atan2(dy, dx) + angleJitter;
                let newSpeed = Math.sqrt(dx * dx + dy * dy);
                dx = newSpeed * Math.cos(newAngle);
                dy = newSpeed * Math.sin(newAngle);
                nonBrickHitCount++;
                consecutiveNoTargetBounces++;
                if (nonBrickHitCount >= 5 || consecutiveNoTargetBounces >= 4) deflectNext = true;
                paddleMode = 'random';
            }

            // Deflect if stuck
            if (deflectNext) {
                deflectBall();
                nonBrickHitCount = 0;
                consecutiveNoTargetBounces = 0;
            }

            // Ball falls below paddle: reset
            if (y + dy > canvas.height - ballRadius) {
                x = canvas.width / 2;
                y = canvas.height - 30;
                speed = 4;
                angle = Math.PI * (0.25 + 0.5 * Math.random());
                dx = speed * Math.cos(angle);
                dy = -speed * Math.sin(angle);
                paddleX = (canvas.width - paddleWidth) / 2;
                paddleMode = 'random';
                nonBrickHitCount = 0;
                consecutiveNoTargetBounces = 0;
            }

            x += dx;
            y += dy;

            updatePaddle();

            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>
